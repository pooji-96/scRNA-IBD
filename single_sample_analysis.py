# -*- coding: utf-8 -*-
"""Single sample analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Dezyk0xgIMqGnPMmyDWmDKLQsLdZrpG5
"""

!pip install scanpy

# Importing packages
import scanpy as sc
import pandas as pd
import numpy as np

# Installing new ones
!conda install -y -c anaconda cmake
!pip install leidenalg
!pip install louvain

!tar -xvf '/content/GSE167377_RAW.tar'

!ls

# Defining a function to read the files into adata for each sample
def read_sample(sample_prefix):
    adata = sc.read_10x_mtx(
        '/content',  # Replace with the path to your data
        var_names='gene_symbols',
        cache=True,
        prefix=sample_prefix
    )
    adata.var_names_make_unique()
    return adata

# Reading each sample data
adata_s1 = read_sample('GSM5104042_S1_')
adata_s2 = read_sample('GSM5104043_S2_')
adata_s3 = read_sample('GSM5104044_S3_')
adata_s4 = read_sample('GSM5104045_S4_')

adata_s1

adata_s2

adata_s3

adata_s4

"""# Analysing single sample"""

adata_s1

"""Quality Control"""

# Filtering out low quality cells and genes
sc.pp.filter_cells(adata_s1, min_genes=200) # removing cells with fewer than 200 genes
sc.pp.filter_genes(adata_s1, min_cells=3)  # removing genes that are found in fewer than 3 cells

adata_s1.obs

# Identifying mitochondrial genes
Mt = ['ND1','ND2','ND3','ND4','ND5','ND6','ND4L','ATP8','ATP6','COX1','COX2','COX3','CYTB','F','V','L1','I','S1','S2','K','T','P','N','L2','E','D','C','Y','Q','R','H','M','A','G','W','EYY68_mgr01','EYY68_mgr02']
adata_s1.var['mt'] = adata_s1.var.index.isin(Mt)

adata_s1.var

# Quality control mertics
sc.pp.calculate_qc_metrics(adata_s1, qc_vars=["mt"], percent_top=None, log1p=False, inplace=True)
# Violin plot
sc.pl.violin(adata_s1, ['n_genes_by_counts', 'total_counts', 'pct_counts_mt'], jitter=0.4, multi_panel=True)

sc.pl.scatter(adata_s1, x='total_counts', y='pct_counts_mt')
sc.pl.scatter(adata_s1, x='total_counts', y='n_genes_by_counts')

# Calculating the upperlimit of the range of genes to be kept for further processing
upper_lim1 = np.quantile(adata_s1.obs.n_genes_by_counts.values, .98)
upper_lim1

# Filtering the data
adata_s1 = adata_s1[adata_s1.obs.n_genes_by_counts.values < upper_lim1]
adata_s1 = adata_s1[adata_s1.obs.pct_counts_mt < 20]

adata_s1

"""Normalization"""

#Normalization
sc.pp.normalize_total(adata_s1, target_sum=1e4)
# Log counts
sc.pp.log1p(adata_s1)
# Saving raw data before further processing
adata_s1.raw = adata_s1

"""Feature selection"""

# Highly variable genes
sc.pp.highly_variable_genes(adata_s1, min_mean=0.0125, max_mean=3, min_disp=0.5)
sc.pl.highly_variable_genes(adata_s1)

# Filtering highly variable
adata_s1 = adata_s1[:,adata_s1.var.highly_variable]

adata_s1.var

adata_s1

# Regress out effects of total counts and mitochondrial counts
sc.pp.regress_out(adata_s1, ['total_counts', 'pct_counts_mt'])

# Scaling the data
sc.pp.scale(adata_s1, max_value = 10)

adata_s1

"""Dimentionality Reduction"""

# Calculating PCA
sc.tl.pca(adata_s1, svd_solver='arpack')
# Plotting PCA
sc.pl.pca_variance_ratio(adata_s1, log=True)

adata_s1

"""Compute the cell neighborhood"""

# Neighborhood graph
sc.pp.neighbors(adata_s1, n_pcs=25)
# Neighborhood matrices
adata_s1.obsp

# Visualization
sc.tl.umap(adata_s1)
sc.pl.umap(adata_s1)

"""Clustering"""

# Clustering the neighborhood graph
sc.tl.leiden(adata_s1, resolution=0.25)
sc.pl.umap(adata_s1, color=['leiden'])

"""Finding markers"""

# Finding markers
sc.tl.rank_genes_groups(adata_s1, 'leiden', method='wilcoxon')
sc.pl.rank_genes_groups(adata_s1, n_genes=25, sharey=False)

# Saving the markers as dataframe
marker_genes = pd.DataFrame(adata_s1.uns["rank_genes_groups"]["names"]).head(10)
marker_genes



